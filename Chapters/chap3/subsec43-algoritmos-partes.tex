%!TEX root = ../../tcc.tex

\newpage
\subsection*{Algoritmos de seleção de partes}

O BitTorrent trata a troca de dados entre \glspl*{peers} como um jogo que, usufruindo
das lógicas existentes na teoria dos jogos, tenta se tornar um ambiente na qual se
buscará as melhores condições de velocidades de download e upload de arquivos e maior
tempo de disponibilidade do \gls*{torrent} na rede.

Por se tratar de um protocolo de troca de dados em partes, uma escolha ruim de quais
destas se adquirir primeiro faz com que seja grande a possibilidade de um \gls*{peer}
baixar alguma parte que seja sempre ofertada por outros \glspl*{peer}. Isso acarretará
em não se ter nenhuma das partes que se deseja. Assim, durante a troca das partes, um
\gls*{peer} adota estratégias diferentes para fornecer e receber blocos de dados, com o
intuito de tentar otimizar a obtenção do conjunto total de dados dos \glspl*{torrent} e ajudando a difundir o conteúdo deste ao resto do \gls*{swarm}.

Para isso, o BitTorrent usa do conceito de \emph{tit-for-tat} (olho por olho), onde um
\gls*{peer} preferirá ajudar \glspl*{peer} que o ajudam, ou seja, só fará upload de
partes para aqueles que o fizerem de volta.

\subsubsection*{Random First Piece}

No início do download de um \gls*{torrent}, um \gls*{peer} não possui partes. Para que
comece a receber partes, ele avisa que é recém-chegado, e assim algum membro do
\gls*{swarm} envia-no uma parte comum aleatoriamente. Dessa forma, ele possuirá uma
``moeda de troca'', podendo então ajudar outros \glspl*{peer} e, assim, conseguirá
melhores condições de ser atendido. É importante que a parte seja comum, pois assim
será possível conseguir blocos de locais diferentes; se fosse rara, seria mais difícil
conseguir completá-la

Após completar a primeira parte, o algoritmo passa para a estratégia de \emph{Rarest
First}.

\subsubsection*{Rarest First}

Nesta fase, o \gls*{peer} passa a pedir as partes mais raras antes. Para isso, utiliza
os bitfields recebidos dos outros \glspl*{peer}, mantendo-os atualizados a cada mensagem
\bverb|have| que recebe. Feito isso, das partes que são menos frequentes nos bifields,
escolhe uma aleatoriamente, devido ao fato de que uma parte rara poderia ser muito
requisitada, o que seria improdutivo.

\begin{comment}
When selecting which piece to start downloading
next, peers generally download pieces which the
fewest of their own peers have first, a technique we
refer to as ’rarest first’. This technique does a good
job of making sure that peers have pieces which all
of their peers want, so uploading can be done when
wanted. It also makes sure that pieces which are
more common are left for later, so the likelihood that
a peer which currently is offering upload will later
not have anything of interest is reduced.
Information theory dictates that no downloaders
can complete until every part of the file has been up-
loaded by the seed. For deployments with a single
seed whose upload capacity is considerably less than
that of many downloaders, performance is much bet-
ter if different downloaders get different pieces from
the seed, since redundant downloads waste the op-
portunity for the seed to get more information out.
Rarest first does a good job of only downloading new
pieces from the seed, since downloaders will be able
to see that their other peers have pieces the seed has
uploaded already.
For some deployments the original seed is eventu-
ally taken down for cost reasons, leaving only current
downloaders to upload. This leads to a very signifi-
cant risk of a particular piece no longer being avail-
able from any current downloaders. Rarest first again
handles this well, by replicating the rarest pieces as
quickly as possible thus reducing the risk of them get-
ting completely lost as current peers stop uploading.
\end{comment}

\subsubsection*{Strict Priority}

\begin{comment}
BitTorrent’s first policy for piece selection is that
once a single sub-piece has been requested, the re-
maining sub-pieces from that particular piece are re-
quested before sub-pieces from any other piece. This
does a good job of getting complete pieces as quickly
as possible.
\end{comment}

\subsubsection*{Endgame Mode}

\begin{comment}
When a download is almost complete, there's a tendency for the last few blocks to trickle in slowly. To speed this up, the client sends requests for all of its missing blocks to all of its peers. To keep this from becoming horribly inefficient, the client also sends a cancel to everyone else every time a block arrives.

Sometimes a piece will be requested from a peer with
very slow transfer rates. This isn’t a problem in the
middle of a download, but could potentially delay a
download’s finish. To keep that from happening, once
all sub-pieces which a peer doesn’t have are actively
being requested it sends requests for all sub-pieces to
all peers. Cancels are sent for sub-pieces which arrive
to keep too much bandwidth from being wasted on
redundant sends. In practice not much bandwidth is
wasted this way, since the endgame period is very
short, and the end of a file is always downloaded
quickly.
\end{comment}