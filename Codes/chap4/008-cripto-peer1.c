// Comentários retirados de
// http://wiki.vuze.com/w/Message_Stream_Encryption#Message_Stream_Encryption_.28aka_PHE.29_format_specification

// A é o remetente
// chave pública de A: $Y_A = (G^X_{A}) \bmod P$
// B é o receptor
// chave pública de B: $Y_B = (G^X_{B}) \bmod P$

/* $P$, $S$, $Y_A$ and $Y_B$ are 768bits long */
#define KEY_LEN 96

/* Prime $P$ is a 768 bit safe prime,
"0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74
   020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F1437
   4FE1356D6D51C245E485B576625E7EC6F44C42E9A63A36210000000000090563"*/
#define PRIME_LEN 96
static const uint8_t dh_P[PRIME_LEN] =
{
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC9, 0x0F, 0xDA, 0xA2,
  0x21, 0x68, 0xC2, 0x34, 0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,
  0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74, 0x02, 0x0B, 0xBE, 0xA6,
  0x3B, 0x13, 0x9B, 0x22, 0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,
  0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B, 0x30, 0x2B, 0x0A, 0x6D,
  0xF2, 0x5F, 0x14, 0x37, 0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,
  0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6, 0xF4, 0x4C, 0x42, 0xE9,
  0xA6, 0x3A, 0x36, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x05, 0x63,
};

/* Generator $G$ is "2" */
static const uint8_t dh_G[] = { 2 };

/* $X_A$ and $X_B$ are a variable size random integers.
They are the private key for each side and have to be discarded after the Diffie-Hellman
(DH) handshake is done. Minimum length is 128 bit. Anything beyond 180 bit is not
believed to add any further security and only increases the necessary calculation time.
You should use a length of 160bits whenever possible, lower values may be used when CPU
time is scarce. */
#define DH_PRIVKEY_LEN_MIN 16
#define DH_PRIVKEY_LEN 20

/* DH secret: $S = (Y_{A}^{X_B}) mod P = (Y_{B}^{X_A}) mod P$ */